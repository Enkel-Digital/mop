/**
 * Express Router for handling appointments
 * Mounted on /appointment
 * @author JJ
 * @module take routes
 */

const express = require("express");
const router = express.Router();
const sendMail = require("../utils/sendMail");
const fs = require("../utils/fs");
const unixseconds = require("unixseconds");
const { asyncWrap } = require("express-error-middlewares");

// Checks if user already have an account, if true, return account ID,
// Else create a new account and return the ID
async function getUserAccountIdIfExists(phoneNumber) {
  const snapshot = await fs
    .collection("users")
    .where("number", "==", phoneNumber)
    .get();

  // If the snapshot is empty, return undefined to specify user does not have an account
  // Else assume only 1 document for that user, and return the document ID of the user document (the first one)
  if (snapshot.empty) return undefined;
  else return snapshot.docs[0].id;
}

// Creates a new user account and returns the user document ID
async function createUserAccount({ fname, lname, number, email }) {
  // Add first to get user document ID
  // The documents are not keyed using email as it can change, they are keyed using firestore autogenerated UID
  const { id } = await fs.collection("users").add({
    fname,
    lname,
    number,
    email,

    // Store time user account is created in unix seconds (this is the time of the server executing the code)
    createdAt: unixseconds(),
  });

  return id;
}

const emailString = (name, timeString, appointmentID) =>
  `Hey ${name}!

Your appointment has been scheduled successfully, and our puppies can't wait to see you on ${timeString}!

Location
https://goo.gl/maps/Jw9MpEPx9cuuGVGDA

Carpark slots are available! Here is a map of the carpark slot and how to get to us from there.
https://goo.gl/maps/UAcHeKbps4EyH4by7

Nearest MRT is Outram Park (EW16 / NE3)

Public transport from Outram Park
https://goo.gl/maps/zB2oUzyMxFnAoBABA

Walking over from Outram Park
https://goo.gl/maps/WQe1cVQo5d8Ztgz76

-----

In the event where your schedule got blocked up and you need to cancel your appointment. Click on the link below!
https://booking.ministryofpup.com/#/cancel/${appointmentID}

-----

Whatsapp us through https://wa.me/6588022177

Email us at ministryofpup@gmail.com

Or call us at 8802,2177 daily between 10am - 8pm for help`;

const getTimeString = (time) =>
  new Intl.DateTimeFormat("en-SG", {
    dateStyle: "full",
    timeStyle: "short",
    timeZone: "Asia/Singapore",
  }).format(new Date(time));

/**
 * Creates an account for the user if it does not already exists, and book a appointment
 * @name POST /appointment/book
 * @returns Sucess indicator
 */
router.post(
  "/book",
  express.json(),
  asyncWrap(async (req, res) => {
    const { token, dogID, time, fname, lname, email } = req.body;

    if (!token) throw new Error("Missing recaptcha token!");

    // Lazily loading the HTTP client library to help with serverless cold start time
    const recaptchaRes = await require("tiny-json-http")
      .post({
        // No freaking idea why but sending data over as a req.body JSON does not work
        // Need to put all the parameters as query string params which is kinda weird...
        // But I have spent too much time on this and since the below works, just sticking with it
        // url: "https://www.google.com/recaptcha/api/siteverify",
        // data: {
        //   secret: process.env.recaptchaSecret,
        //   response: token,
        //   remoteip: req.headers["x-forwarded-for"] || req.socket.remoteAddress,
        // },

        url: `https://www.google.com/recaptcha/api/siteverify?secret=${
          process.env.recaptchaSecret
        }&response=${token}&remoteip=${
          req.headers["x-forwarded-for"] || req.socket.remoteAddress
        }`,
      })
      .then((resp) => resp.body);

    if (!recaptchaRes.success) throw new Error(recaptchaRes["error-codes"]);
    if (recaptchaRes.score < 0.6)
      throw new Error(`Recaptcha score too low: ${recaptchaRes.score}`);

    // Remove all white space from phone number
    const number = req.body.number.replace(" ", "");

    // Get the user ID either from an existing account, or from a newly created account
    const userID =
      (await getUserAccountIdIfExists(number)) ||
      (await createUserAccount({ fname, lname, number, email }));

    // Lazily import this to keep serverless container start up time fast as this is not always used
    const { createAndInsertEvent } = require("../utils/GoogleCalendar");

    // @todo Handle on failure and still store appointment into DB + notify developer
    // Get the event ID back and store it to programmatically delete or modify it later on if needed
    // Add appointment event to google cal first to get back the event ID to store in appointment doc
    // However by doing this first, means that the appointment ID cannot be added into the description
    // https://developers.google.com/calendar/api/v3/reference/events#id
    const googleCalendarEventID = await createAndInsertEvent({
      start: time,

      summary: `Appointment with ${fname}`,
      description: "Checkout this appointment in the admin portal",
      // Cannot do the below now because, the appointmentID is not generated before google cal insert....
      // description: `Checkout this appointment in the admin portal\nhttps://admin.ministryofpup.com/#/appointment/${appointmentID}`,
      // description: `AppointmentID: ${appointmentID}\nPortal's link`,
    });

    const { id: appointmentID } = await fs.collection("appointments").add({
      user: userID,

      // Although the `googleCalendarEventID` can be used as the doc ID for appointments, it is safer because,
      // 1. If google calendar API call failed, the appointment data should still be stored
      // 2. If there is ever a time to store appointment directly into the DB its easier to let firestore auto generate
      // 3. It is better to keep these 2 seperate and not have our appointments DB rely on google cal for doc ID
      googleCalendarEventID,

      dogID,
      time,
      fname,
      lname,
      number,
      email,

      // Store time appointment was created in unix seconds (this is the time of the server executing the code)
      createdAt: unixseconds(),
    });

    const timeString = getTimeString(time);

    // Send user a email to confirm with them that their appointment has been scheduled successfully
    // @todo Copy over the stuff from whats added into the user's google calendar
    await sendMail.send({
      to: email,
      from: process.env.notificationEmailSender,
      subject: `Ministry Of Pup: Appointment booked for ${timeString}!`,
      text: emailString(fname, timeString, appointmentID),
    });

    // await sendMail.send({
    //   to: email,
    //   from: process.env.notificationEmailSender,
    //   templateId: "d-a9b0fbf8e5004f76955df83d36efcab3",
    //   dynamicTemplateData: { timeString },
    // });

    // Notify admins about new appointment using the telegram notification bot
    const notifyAdmin = require("../utils/tAdminNotification.js");
    notifyAdmin(`*New appointment*

${timeString}
User: *${fname}*
ID: _${appointmentID}_`);

    // appointmentID is returned so that the booking app can generate the calendar event,
    // with a link for cancelling appointment using this appointmentID
    res.status(200).json({ ok: true, appointmentID });
  })
);

/**
 * Cancel an existing appointment and delete the event in google calendar.
 * This is a POST request instead of a DELETE request to not deal with handling CORS preflight request for DELETE methods.
 * @name POST /appointment/cancel/:appointmentID
 * @returns Sucess indicator
 */
router.post(
  "/cancel/:appointmentID",
  asyncWrap(async (req, res) => {
    const { appointmentID } = req.params;

    // @todo Handle the recaptcha token

    const docRef = fs.collection("appointments").doc(appointmentID);

    // Keeping user data for future use and analytics, just adding a cancelled field
    await docRef.update({ cancelled: true });

    // Get the `googleCalendarEventID` from doc to delete the event from google calendar
    const doc = await docRef.get();
    if (!doc.exists) throw new Error("Appointment does not exist in DB");

    // Lazily import this to keep serverless container start up time fast as this is not always used
    const { deleteEvent } = require("../utils/GoogleCalendar");

    const docData = doc.data();
    await deleteEvent(docData.googleCalendarEventID);

    // Notify admins about new appointment using the telegram notification bot
    const notifyAdmin = require("../utils/tAdminNotification.js");
    notifyAdmin(`*Appointment cancelled*
   
${getTimeString(docData.time)}
User: *${docData.fname}*
ID: _${doc.id}_`);

    res.status(200).json({ ok: true });
  })
);

module.exports = router;
